<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>eth on 洛舒luosuu的小站</title>
    <link>https://luosuu.github.io/categories/eth/</link>
    <description>Recent content in eth on 洛舒luosuu的小站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright © 2020</copyright>
    <lastBuildDate>Thu, 05 Mar 2020 19:21:47 +0800</lastBuildDate>
    
	<atom:link href="https://luosuu.github.io/categories/eth/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Smart Contrast Dev</title>
      <link>https://luosuu.github.io/post/smart-contrast-dev/</link>
      <pubDate>Thu, 05 Mar 2020 19:21:47 +0800</pubDate>
      
      <guid>https://luosuu.github.io/post/smart-contrast-dev/</guid>
      <description>&lt;p&gt;本文主要参考于&lt;a href=&#34;https://solidity-cn.readthedocs.io/zh/develop/introduction-to-smart-contracts.html&#34;&gt;Solidity develop文档&lt;/a&gt;。作为本人的学习笔记和再理解。&lt;/p&gt;
&lt;h2 id=&#34;对solidity的初步了解&#34;&gt;对solidity的初步了解&lt;/h2&gt;
&lt;p&gt;Solidity是针对以太坊的编程语言，受到C++，Python，JavaScript等语言的影响。它的设计目的就是为了在以太坊上运行。&lt;/p&gt;
&lt;p&gt;它是一种静态语言。solidity支持一部分类的特性。solidity同样支持继承，和复杂的由用户自定义的特殊类型。因此我们可以说solidity是一种OOP（面对对象）的语言。我们在编写solidity代码时，应该以面对对象的编程方式定义变量（状态）和函数。并在solidity中，是大小写敏感的。&lt;/p&gt;
&lt;p&gt;我们知道以太坊上的每个节点实际上一般都是EVM，就算是矿工节点，一般也承担EVM的职责。以太坊区块链通过编写和执行智能合约来帮助拓展它的功能。EVM支持的语言很多，solidity是其中最流行也是最适合的。&lt;/p&gt;
&lt;h2 id=&#34;evm和solidity&#34;&gt;EVM和solidity&lt;/h2&gt;
&lt;p&gt;EVM是最终执行智能合约代码的地方，但是它不能直接理解solidity里面的高级的结构。EVM能理解的是一种被称为&lt;strong&gt;字节码&lt;/strong&gt;的一种低级指令。这种指令非常精简。深入了解EVM，你会发现EVM在实际运行代码时不能联网，权限也非常有限。包括使用精简的指令在内的这些特性，都是为了保证EVM的安全性。&lt;/p&gt;
&lt;p&gt;要把我们编写的solidity代码转换成字节码，需要编译器。solidity附带的编译器成为solidity编译器或者&lt;strong&gt;solc&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么这个工作流程就和普通的编译代码并运行它没有什么太大的区别了。&lt;/p&gt;
&lt;p&gt;solidity代码 -&amp;gt; solc -&amp;gt; 字节码 -&amp;gt; 部署并在EVM上运行。&lt;/p&gt;
&lt;h2 id=&#34;solidity文件&#34;&gt;solidity文件&lt;/h2&gt;
&lt;p&gt;储存solidity代码的solidity文件的拓展名是&lt;code&gt;.sol&lt;/code&gt;。solidity文件是人类可读的文件，可以在任何编辑器，甚至可以在记事本里打开。&lt;/p&gt;
&lt;p&gt;solidity文件由以下四个高级结构组成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预编译指令 - pragma&lt;/li&gt;
&lt;li&gt;注释&lt;/li&gt;
&lt;li&gt;导入(import)&lt;/li&gt;
&lt;li&gt;合约/库/接口 - contract/library/interface&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中solidity的注释是和C++是一样的，&lt;code&gt;\\&lt;/code&gt;是单行注释，&lt;code&gt;\* *\&lt;/code&gt;是多行注释。&lt;/p&gt;
&lt;p&gt;它们整体看起来像是这个样子的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pragma solidity&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;contract&lt;/span&gt; a{
    &lt;span style=&#34;color:#75715e&#34;&gt;//***
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;span style=&#34;color:#66d9ef&#34;&gt;library&lt;/span&gt; b{
    &lt;span style=&#34;color:#75715e&#34;&gt;//***
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; c{
    &lt;span style=&#34;color:#75715e&#34;&gt;//***
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;import语句&#34;&gt;import语句&lt;/h3&gt;
&lt;p&gt;帮助我们导入其他solidity文件，使得当前的solidity文件可以访问其中的代码。这有助于我们编写模块化的代码。如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;commonLibrary.sol&amp;#39;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;预编译指令&#34;&gt;预编译指令&lt;/h3&gt;
&lt;p&gt;通常指solidity文件的第一行代码，其形式一般为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pragma solidity&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;version number&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意是有分号作为结束的。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;pragma&lt;/code&gt;指令的帮助下，你可以为你的代码选择合适的编译器。这是一种很好的习惯。&lt;/p&gt;
&lt;p&gt;其中版本号&lt;code&gt;^0.4.0&lt;/code&gt;代表版本号为4的最新的版本。&lt;/p&gt;
&lt;h2 id=&#34;hello-world&#34;&gt;Hello world&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pragma solidity&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;contract&lt;/span&gt; Helloworld{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello world&amp;#34;&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; GetHelloWorld() &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;view&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;returns&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;){
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是用solidity输出&amp;quot;Hello world&amp;quot;的一个范例。我们可以从中简单的窥见solidity声明变量和函数的一些特点。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pragma&lt;/code&gt;关键字代表着编译器应该如何处理源代码，常见的就是声明使用的编译器版本。 我们可以窥见我们写的所谓合约&lt;code&gt;contract&lt;/code&gt;其实在写一个很类似于C++类的东西，在其中声明了该合约的成员和成员函数，或公有供别人调用，或私有进行保护。&lt;/p&gt;
&lt;p&gt;我们写了这个合约，就可以进行发布，将它写在区块上，使其拥有一个特定的地址，这样别人就可以通过这个地址使用我们写的合约了。&lt;/p&gt;
&lt;h2 id=&#34;存储&#34;&gt;存储&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pragma solidity&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;contract&lt;/span&gt; SimpleStorage {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt; storedData;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; set(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt; x) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; {
        storedData &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; get() &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;view&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;returns&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; storedData;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;unit&lt;/code&gt;这个变量类型是最高256位的无符号整数，我们在上述代码里声明了一个&lt;code&gt;unit&lt;/code&gt;类型的状态变量，叫做&lt;code&gt;storedDate&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;后面我们声明了两个函数&lt;code&gt;set&lt;/code&gt;与&lt;code&gt;get&lt;/code&gt;，用于设定和返回合约&lt;code&gt;SimpleStorage&lt;/code&gt;的成员&lt;code&gt;storedDate&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在solidity中，我们不需要&lt;code&gt;this.&lt;/code&gt;来访问合约内部的变量。&lt;/p&gt;
&lt;h2 id=&#34;一个简单的货币实现&#34;&gt;一个简单的货币实现&lt;/h2&gt;
&lt;p&gt;实际上，public关键字会让编译器自动生成函数，用于返回public变量或函数，理解这一点尤其重要。我们将分析下面这个最简单的加密货币：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pragma solidity&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;21&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;contract&lt;/span&gt; Coin {
    &lt;span style=&#34;color:#75715e&#34;&gt;// 关键字“public”让这些变量可以从外部读取
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; minter;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;mapping&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; balances;

    &lt;span style=&#34;color:#75715e&#34;&gt;// 轻客户端可以通过事件针对变化作出高效的反应
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;event&lt;/span&gt; Sent(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; to, &lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt; amount);

    &lt;span style=&#34;color:#75715e&#34;&gt;// 这是构造函数，只有当合约创建时运行
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; Coin() &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; {
        minter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; msg.sender;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; mint(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; receiver, &lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt; amount) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (msg.sender &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; minter) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        balances[receiver] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; amount;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; send(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; receiver, &lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt; amount) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (balances[msg.sender] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; amount) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        balances[msg.sender] &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; amount;
        balances[receiver] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; amount;
        emit Sent(msg.sender, receiver, amount);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们在这里遇到了新的变量类型，&lt;code&gt;address&lt;/code&gt;。 &lt;code&gt;address&lt;/code&gt;类型是一个160位的值，如果你知道在以太坊中，用户之间是通过每个用户的公钥的前160位来区别，那么将很好理解。代码里我们声明了一个叫做&lt;code&gt;minter&lt;/code&gt;的&lt;code&gt;address&lt;/code&gt;的公有变量。 &lt;code&gt;public&lt;/code&gt;关键字对于&lt;code&gt;minter&lt;/code&gt;来讲，编译器自动生成的代码大致如下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; minter() &lt;span style=&#34;color:#66d9ef&#34;&gt;returns&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt;) { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; minter; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译器通过这种方式，使&lt;code&gt;minter&lt;/code&gt;可以被其他合约访问。&lt;/p&gt;
&lt;p&gt;下一行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mapping&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; balances;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们声明了一个叫做&lt;code&gt;balances&lt;/code&gt;的公有变量，那么它的类型怎么理解呢？我们可以将它理解为一个转换器，也就是对于&lt;code&gt;balances(address _account)&lt;/code&gt;，它返回的是一个&lt;code&gt;unit&lt;/code&gt;类型，并且每个&lt;code&gt;_account&lt;/code&gt;都有互相独立的空间，你可以理解每个&lt;code&gt;_account&lt;/code&gt;可以通过&lt;code&gt;balances&lt;/code&gt;拥有一个自己成员/属性，就是自己的一个&lt;code&gt;unit&lt;/code&gt;类型的值。通过&lt;code&gt;balances&lt;/code&gt;我们实现了使每一个地址的用户都有储存自己余额的地方，我们也可以通过&lt;code&gt;balances&lt;/code&gt;管理每个用户的余额从而实现货币的流通（实际上在以太坊里，&lt;code&gt;balances&lt;/code&gt;就代表余额的意思）。我们一般可以称类似于&lt;code&gt;balances&lt;/code&gt;这种变量为&lt;strong&gt;状态变量&lt;/strong&gt;。 &lt;code&gt;public&lt;/code&gt;关键字对&lt;code&gt;balances&lt;/code&gt;生成的代码大致如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; balances(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; _account) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;view&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;returns&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; balances[_account];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以看到通过&lt;code&gt;balances&lt;/code&gt;轻松的查询到每一位用户的余额。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;event&lt;/span&gt; Sent(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; to, &lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt; amount);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;event&lt;/code&gt;变量，即“事件”。这种变量类型是用来被传输信息的，也就是说可以被传送出去，并且携带一些我们希望它携带的信息。而用来监听这个事件并且获得信息的代码示例如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;Coin.Sent().watch({}, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(error, result) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;error) {
        console.log(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Coin transfer: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; result.args.amount &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; coins were sent from &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; result.args.&lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; to &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; result.args.to &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;);
        console.log(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Balances now:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Sender: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Coin.balances.call(result.args.&lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Receiver: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Coin.balances.call(result.args.to));
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用户可以通过在自己的应用程序或者服务器上添加上面这个代码来获取事件的信息。这是&lt;code&gt;event&lt;/code&gt;类型数据所允许的一种方式。&lt;/p&gt;
&lt;p&gt;请一定要注意&lt;code&gt;balances&lt;/code&gt;函数是如何在用户界面调用的。不再是通过&lt;code&gt;balances(_address)&lt;/code&gt;这种形式，而是通过&lt;code&gt;balances.call(_address)&lt;/code&gt;这种形式调用。&lt;/p&gt;
&lt;p&gt;然后我们看到了构造函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; Coin() &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; {
        minter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; msg.sender;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;构造函数&lt;code&gt;Coin()&lt;/code&gt;只会在合约创建的时候被调用，存入合约创建者的地址。&lt;code&gt;msg&lt;/code&gt;是一个全局变量，其中&lt;code&gt;msg.sender&lt;/code&gt;始终是当前函数调用的来源地址。这样就可以理解函数的内容了。&lt;/p&gt;
&lt;p&gt;函数&lt;code&gt;mint&lt;/code&gt;和&lt;code&gt;send&lt;/code&gt;是完成合约功能的两个函数。&lt;/p&gt;
&lt;p&gt;函数&lt;code&gt;mint&lt;/code&gt;会先检验调用者是不是合约创建者，如果不是，那么就什么都不会发生，直接返回。而如果调用者就是合约创建者，就会执行内容，也就是给指定的接受地址的用户增加余额。&lt;/p&gt;
&lt;p&gt;函数&lt;code&gt;send&lt;/code&gt;允许任何人调用，用于将自己的货币的余额的一部分转移到指定接受账户的余额里。并且送出事件&lt;code&gt;Sent&lt;/code&gt;用于告知所有用户。后面就是用户更新自己账本了。具体流程可以看我的其他文档。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Basic Eth</title>
      <link>https://luosuu.github.io/post/basic-eth/</link>
      <pubDate>Thu, 05 Mar 2020 19:19:47 +0800</pubDate>
      
      <guid>https://luosuu.github.io/post/basic-eth/</guid>
      <description>&lt;p&gt;一些以太坊基础知识&lt;/p&gt;
&lt;h2 id=&#34;区块是怎么连接的&#34;&gt;区块是怎么连接的&lt;/h2&gt;
&lt;p&gt;在区块链和以太坊中，每个区块都连接着另外一个区块，区块依次相连，形成一条长链。其中第一个区块成为&lt;strong&gt;创世区块&lt;/strong&gt;。创世区块通过&lt;code&gt;genesis.json&lt;/code&gt;文件产生。&lt;/p&gt;
&lt;p&gt;区块链中，两个相邻的区块之间是父子的关系，并且是一对一的关系（每个子都只有一个父）。那么如何确认这种关系并且将他们连接在一起呢？&lt;/p&gt;
&lt;p&gt;每个区块都由两个部分组成，区块头和区块体。其中区块头存储着当前区块的特征值，它包含了很多属性，如生成该区块的时间，本区块的区块体的散列，上一个区块的散列…&lt;/p&gt;
&lt;p&gt;通过上一个区块的散列这一属性，我们就将区块连接在一起了，并且可以互相认证。&lt;/p&gt;
&lt;p&gt;由于散列的特殊性，如果区块体的内容改变，那么她的散列一定会改变，那么就会连锁性质的导致它的子块，和子块下面的所有块都要改变。&lt;/p&gt;
&lt;p&gt;而快速改变多个区块是几乎不可能的，这要求它占据全网51%的算力。这样的方式保证了区块链的不可篡改性质。&lt;/p&gt;
&lt;h2 id=&#34;区块体的散列值的产生-merkle根数&#34;&gt;区块体的散列值的产生-Merkle根数&lt;/h2&gt;
&lt;p&gt;区块头的哈希值是怎么产生的？答案是&lt;strong&gt;Merkle根树&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Merkle根叔，又称哈希二叉树(Merkle tree)。&lt;/p&gt;
&lt;p&gt;每个被储存在区块里的交易都会产生一个散列值，每个交易都有自己的时间戳，在区块里他们会按时间顺序排序，然后挖矿程序会按照顺序将它们两个一组两个一组的分组。&lt;/p&gt;
&lt;p&gt;如果恰巧交易ID的总共数量为奇数个呢？那么排在最后的这个交易ID就copy自己一份，凑成偶数。&lt;/p&gt;
&lt;p&gt;每个组的两个成员的哈希值相连接成为一个长字符串，然后在对其产生哈希，然后不断重复分组-相连-产生哈希的过程，最终生成最后的一个哈希值，这就是&lt;strong&gt;Merkle根哈希值(Merkle root)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Merkle tree大部分都是二叉的，但是也有别的形式的，三叉及以上也是有可能的。&lt;/p&gt;
&lt;h3 id=&#34;merkle-tree有什么用&#34;&gt;Merkle tree有什么用&lt;/h3&gt;
&lt;p&gt;在说这个之前，我们要提一句另外一种产生一系列内容的哈希值的方式，Hash List。&lt;/p&gt;
&lt;p&gt;Hash List非常简单，就是对每一项内容都产生一个哈希，把这些哈希放进一个列表里，也就是Hash List，然后把这些哈希全都连接在一起，在对其产生一个哈希，用来检验Hash List。&lt;/p&gt;
&lt;p&gt;通过Merkle tree这种方式产生哈希，在P2P网络下载整个网络之前，我们可以先从可信源获得Merkle root，然后从其他不可信源下载Merkle tree，对比二者的Merkle root，由于哈希值的唯一性，我们可以认为如果Merkle root一致，那么整个Merkle tree都是正确的。在获得整棵树后，我们就可以单独对树上的某只分支进行验证了。&lt;/p&gt;
&lt;p&gt;从网络上下载，需要先进行验证保证内容的正确可信，这也是Merkle tree和Hash List的意义之一。验证通过后才能进行下载。&lt;/p&gt;
&lt;p&gt;Merkle tree和Hash List的主要区别在于，如果一部分内容损坏，Merkle tree的方式允许我们只下载这一部分数据所在的分支，然后验证这一个分支，验证通过后我们就可以开始下载内容了。Hash List则要求我们下载完整的Hash List才能验证。&lt;/p&gt;
&lt;h2 id=&#34;什么是gas&#34;&gt;什么是gas&lt;/h2&gt;
&lt;p&gt;gas，译为“燃料”。以太坊作为平台，对用户的每一项操作都要收取手续费，而衡量应该收取手续费的多少的计量单位就是gas。&lt;/p&gt;
&lt;p&gt;但是我们知道区块链技术是去中心的，这个手续费交给的不是平台，当然是为你做出计算劳动的矿工（尽管你支付给的对象的确是网络，但是网络会直接按照劳动量分配给矿工）。而平台只是表明多少计算量需要多少的gas。需要越多计算资源的操作自然需要的gas越多。&lt;/p&gt;
&lt;p&gt;但是gas是没有任何实际的标记（token）的，也就是说你不能拥有1000个gas之类的，gas只存在与以太坊虚拟机的内部，计算你所需的操作消耗的gas数量。以太坊会直接计算你的操作需要多少计算资源，然后将他们换算成gas。在你支付的时候，它们在换算成ether（以太坊内置机制中矿工生成区块记录内容的奖励）。&lt;/p&gt;
&lt;h2 id=&#34;为什么需要gas&#34;&gt;为什么需要gas&lt;/h2&gt;
&lt;p&gt;以太坊直接有ether作为货币，为什么不直接以ether交易呢？这是由于以太坊在交易所进行公开买卖，它的价格会飘忽不定，这样你在以太坊内的操作的价格就会可能剧烈波动，在以太币的价格较低时如果人们交易量很大，那么可能就会形成“峰谷效应”，也就是执行量过大，造成平台超负荷运行。而gas可以缓解这一过程。等量计算资源消耗的操作所需要的gas数量是不变的，是事先确定的。&lt;/p&gt;
&lt;h2 id=&#34;如何支付gas&#34;&gt;如何支付gas&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;你最终的成本 = gas数量*gas单价
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我每进行一个操作，都需要提前标注好自己的gas单价，然后附加上实际的以太币。你的gas单价会决定你在队列中的优先度，大家当然愿意先服务单价高的客户。接下来的情况就和你附加的以太币的数量有关了。&lt;/p&gt;
&lt;p&gt;矿工们每付出一些计算资源他们就会得到奖励，他们不会预先知道你附加的以太币是否足够支付整个操作，所以你的以太币是一点点被消耗的。矿工们的付出和获得是需要持久的，当停止支付时他们就会停止工作。所以如果你进行的&lt;code&gt;操作需要的gas数量*你标记的gas单价 &amp;gt; 你附加的以太币&lt;/code&gt;，当你的以太币消耗完了之后，他们就会停止工作。然后他们会还原之前的处理，但是仍然会把这项交易失败的记录写入区块里，作为收取你费用的记录。而你会被提示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;您的交易中出现的gas与您的交易之间存在差异，没有足够高的费用来支持交易（out of gas）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可能会觉得这个设计很坑，操作失败了竟然不给我退款，但是这是为了整个系统的稳定，矿工们付出了劳动，理应得到奖励。这要求每一个请求操作的人都谨慎的处理自己的代码，并且保证了系统的安全性，对整个系统来说是有益的。&lt;/p&gt;
&lt;p&gt;而如果你支付的以太币足够多，当请求的操作结束之后，会退还给你附加的多余的以太币。&lt;/p&gt;
&lt;h2 id=&#34;gas的限制&#34;&gt;gas的限制&lt;/h2&gt;
&lt;p&gt;我们知道交易储存在区块中。在以太坊里，每个区块都有gas上限。待执行的交易要消耗的gas不能超过这个上限，这样就避免了所有区块都储存在最后一个区块里，达到gas上限后，其他交易就不能写入这个区块了，就会逼迫矿工挖矿，挖出下一个节点。这样可以保证整个系统的区块不断延长，保证整个系统的安全性。&lt;/p&gt;
&lt;h2 id=&#34;各种系统安装geth的办法&#34;&gt;各种系统安装Geth的办法&lt;/h2&gt;
&lt;h2 id=&#34;ubuntu&#34;&gt;Ubuntu&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo apt-get install software-properties-common
sudo add-apt-repository -y ppa:ethereum/ethereum
sudo apt-get update
sudo apt-get install ethereum
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;禁用了ppa源的linux发行版&#34;&gt;禁用了PPA源的Linux发行版&lt;/h2&gt;
&lt;p&gt;可以考虑编译安装。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;git clone https://github.com/ethereum/go-ethereum
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安装Go&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo apt install golang
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译安装&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo apt-get install -y build-essential
cd go-ethereum
make geth
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后在最后的运行结果里你就可以知道你启动geth的路径，你可以把它加在你的环境变量里方便你使用。&lt;/p&gt;
&lt;h2 id=&#34;如何方便地启动geth&#34;&gt;如何方便地启动geth&lt;/h2&gt;
&lt;p&gt;在你安装完geth后，会告诉你geth的安装路径，在shell中直接输入该路径，geth就启动了。&lt;/p&gt;
&lt;p&gt;但是我们想在shell中输入geth就能直接启动，而不是每次都要输入长长的路径。&lt;/p&gt;
&lt;p&gt;这里介绍一种办法。这个办法就是在用户目录下创建一个叫做&lt;code&gt;bin&lt;/code&gt;文件夹，然后将其中储存一个软链接，链接到geth的路径。然后在&lt;code&gt;.zshrc&lt;/code&gt;中添加环境变量，将咱们刚刚创建的&lt;code&gt;bin&lt;/code&gt;文件夹添加进去。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 进入用户家目录，也就是～&lt;/span&gt;
cd
&lt;span style=&#34;color:#75715e&#34;&gt;# 创建文件夹&lt;/span&gt;
mkdir bin
&lt;span style=&#34;color:#75715e&#34;&gt;# 创建软链接&lt;/span&gt;
ln -s &amp;lt;geth路径&amp;gt; ～/bin/geth
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;至此我们成功地将软链接添加好了。&lt;/p&gt;
&lt;p&gt;然后我们添加环境变量。我们应该编辑&lt;code&gt;.zshrc&lt;/code&gt;文件。在最后添加如下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;export PATH &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $PATH:~/bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;export是添加环境变量的语句，并且是一次性的。由于我们将它写入的&lt;code&gt;.zshrc&lt;/code&gt;中，也就是zsh的配置文件，每次我们启动shell的时候都会随zsh的启动而实施。&lt;/p&gt;
&lt;p&gt;以上的方法是受推崇的，这样的做法十分安全，避免了sudo。并且保证了每个用户的独立性，也就是每个用户自己软件的不可见性。&lt;/p&gt;
&lt;p&gt;如果是个人用户，可以不这么麻烦。可以直接放在&lt;code&gt;/usr/local/bin&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo ln -s &amp;lt;geth路径&amp;gt; /usr/local/bin/geth
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样需要sudo，并且如果是在服务器端，那么所有服务器用户都可以使用。&lt;/p&gt;
&lt;h2 id=&#34;geth搭建私链&#34;&gt;Geth搭建私链&lt;/h2&gt;
&lt;h2 id=&#34;创建目录&#34;&gt;创建目录&lt;/h2&gt;
&lt;p&gt;首先我们需要创建一个我们用于储存私链数据的文件夹，geth客户端工作的时候导入数据就要从其中导入。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;mkdir private-geth
cd private-geth
touch gensis.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;创世区块&#34;&gt;创世区块&lt;/h2&gt;
&lt;p&gt;我们新建的&lt;code&gt;gensis.json&lt;/code&gt;文件是创世区块的配置文件。&lt;/p&gt;
&lt;p&gt;这个文件会保证没有其他节点和你的节点的区块链版本一致，除非他们的创世区块的配置文件和你一模一样。&lt;/p&gt;
&lt;p&gt;每条链都应该有创世区块，也自然应该有自己的&lt;code&gt;gensis.json&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以下是一个例子，你需要在了解其中的各项参数的意义后自己更改一下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;config&amp;#34;&lt;/span&gt;:{
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;chainId&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;39&lt;/span&gt;,
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;homesteadBlock&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;eip155Block&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;eip158Block&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
},
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;alloc&amp;#34;&lt;/span&gt;      :{
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;0xeb680f30715f347d4eb5cd03ac5eced297ac5046&amp;#34;&lt;/span&gt;:{&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;balance&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;10000000000000000&amp;#34;&lt;/span&gt;}},
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;coinbase&amp;#34;&lt;/span&gt;   : &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0x0000000000000000000000000000000000000000&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;difficulty&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0x20000&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;extraData&amp;#34;&lt;/span&gt;  : &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;gasLimit&amp;#34;&lt;/span&gt;   : &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0xffffffff&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;nonce&amp;#34;&lt;/span&gt;      : &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0x0000000000000039&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;mixhash&amp;#34;&lt;/span&gt;    : &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0x0000000000000000000000000000000000000000000000000000000000000000&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;parentHash&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0x0000000000000000000000000000000000000000000000000000000000000000&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;timestamp&amp;#34;&lt;/span&gt;  : &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0x00&amp;#34;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中&lt;code&gt;alloc&lt;/code&gt;代表初始账号，并且分配给他一定的余额。&lt;/p&gt;
&lt;p&gt;建议这里设置一个初始账号，方便我们以后的操作。账号可以自己随便写，只要格式正确，长度正确就可以，因为我们不会实际使用这个账号。&lt;/p&gt;
&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;
&lt;p&gt;然后我们需要使用创世区块的配置文件初始化我们的私链。首先我们需要一个储存链数据的位置。&lt;/p&gt;
&lt;p&gt;我们推荐在我们刚才创建的文件夹里在创建一个文件夹。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 名字不重要&lt;/span&gt;
mkdir db
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后我们需要执行初始化命令，进入我们最开始创建的文件夹里。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;geth --datadir &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./db&amp;#34;&lt;/span&gt; init gensis.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;--datadir &amp;quot;./db&amp;quot;&lt;/code&gt;代表指定存储位置，后面的代表将&lt;code&gt;gensis.json&lt;/code&gt;作为初始化配置文件。&lt;/p&gt;
&lt;p&gt;然后你可以进去使用ls命令看看里面都有些什么。&lt;/p&gt;
&lt;h2 id=&#34;启动节点&#34;&gt;启动节点&lt;/h2&gt;
&lt;p&gt;进入我们最开始创建的文件夹，使用以下命令启动节点。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;geth --datadir &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./db&amp;#34;&lt;/span&gt; --rpc --rpcaddr&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0.0.0.0 --rpcport &lt;span style=&#34;color:#ae81ff&#34;&gt;8545&lt;/span&gt; --rpccorsdomain &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt; --rpcapi &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;eth,net,web3,personal,admin,shh,txpool,debug,miner&amp;#34;&lt;/span&gt; --nodiscover --maxpeers &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt; --networkid &lt;span style=&#34;color:#ae81ff&#34;&gt;3909&lt;/span&gt; --port &lt;span style=&#34;color:#ae81ff&#34;&gt;30303&lt;/span&gt; --mine --minerthreads &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; --etherbase &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0xeb680f30715f347d4eb5cd03ac5eced297ac5046&amp;#34;&lt;/span&gt; --allow-insecure-unlock console
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中&lt;code&gt;--allow-insecure-unlock&lt;/code&gt;我推荐加上去，否则会在后面的解锁账户时遇到麻烦，&lt;strong&gt;现在不允许以默认的方式解锁带http接口的账户了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-rpc&lt;/code&gt;就是开启了HTTP-RPC服务。&lt;/p&gt;
&lt;p&gt;启动节点后他就会开始挖矿。挖矿账户就是我们在&lt;code&gt;gensis.json&lt;/code&gt;里设置的账户。&lt;/p&gt;
&lt;p&gt;最后我们如果想进一步操作，需要进入Geth的JavaScript控制台。&lt;/p&gt;
&lt;p&gt;我们需要通过attach命令，连接一个已经启动的节点，这里推荐新开一个终端窗口。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;geth --datadir &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;./db&amp;#39;&lt;/span&gt; attach ipc:./db/geth.ipc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;以太坊javascript控制台命令&#34;&gt;以太坊JavaScript控制台命令&lt;/h2&gt;
&lt;p&gt;以太坊JavaScript控制台中内置了一些对象，方便我们和以太坊交互，其中有eth, net, admin, miner, personal, txpool, web3。&lt;/p&gt;
&lt;h3 id=&#34;新建账号&#34;&gt;新建账号&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-JavaScript&#34; data-lang=&#34;JavaScript&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;personal&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;newAccount&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;123456&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;括号里的字符串是你新建账号的密码。显示出的结果就是账号的公钥。&lt;/p&gt;
&lt;p&gt;生成的账户会保存在keystore文件夹。&lt;/p&gt;
&lt;p&gt;你可以新建两个账号，用于接下来我们尝试进行交易。&lt;/p&gt;
&lt;p&gt;新建完账号后，可以使用如下命令来查看当前链的账户。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-JavaScript&#34; data-lang=&#34;JavaScript&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;eth&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;accounts&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出结果就是当前链的所有账户了。他们以数组的形式储存，所以可以用诸如&lt;code&gt;eth.accounts[0]&lt;/code&gt;的形式调用它们。&lt;/p&gt;
&lt;p&gt;然后我们可以看看他们的余额。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-JS&#34; data-lang=&#34;JS&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;balance&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;web3&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;fromWei&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;eth&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getBalance&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;eth&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;accounts&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]),&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ether&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;eth.getBlance&lt;/code&gt;返回的是以wei为单位的余额，上面的命令，将wei单位转化为了ether单位。&lt;/p&gt;
&lt;p&gt;新建的两个账户的余额自然是0，想要实现交易至少得先有以太币，所以我们需要用一个账户挖矿，获得奖励。&lt;/p&gt;
&lt;h3 id=&#34;挖矿&#34;&gt;挖矿&lt;/h3&gt;
&lt;p&gt;首先设立本机挖矿奖励地址。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-JS&#34; data-lang=&#34;JS&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;miner&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;setEtherbase&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;eth&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;accounts&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后检查一下是否设置成功&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-JS&#34; data-lang=&#34;JS&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;eth&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;coinbase&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面这条命令就会返回挖矿的奖励地址。&lt;/p&gt;
&lt;p&gt;然后启动挖矿。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-JS&#34; data-lang=&#34;JS&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;miner&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;括号里的数字代表线程数，代表开启几个线程进行挖矿。&lt;/p&gt;
&lt;p&gt;你可能遇到返回是&lt;code&gt;null&lt;/code&gt;的情况，你可以检查下区块高度&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-JS&#34; data-lang=&#34;JS&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;eth&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;blockNumber&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;会返回一个数字，代表着现在的区块高度，你隔段时间检查一下，如果区块高度增高了，说明它已经开始挖矿了，没有问题。&lt;/p&gt;
&lt;p&gt;据我粗略观察，应该是咱们开了一个新的窗口，挖矿的具体信息都在原先的窗口里，如果你担心区块高度的增加是因为原先的挖矿没有停止，你可以先用&lt;code&gt;miner.stop()&lt;/code&gt;，再用&lt;code&gt;miner.start(1)&lt;/code&gt;,然后检查区块高度是否增加&lt;/p&gt;
&lt;h3 id=&#34;交易&#34;&gt;交易&lt;/h3&gt;
&lt;p&gt;进行一段时间的挖矿后，你说设置的奖励账户里的余额应该增加了。&lt;/p&gt;
&lt;p&gt;然后就可以进行交易的准备。&lt;/p&gt;
&lt;p&gt;首先我们需要解锁账户，才能实施交易。之前在启动geth时添加的参数中，&lt;code&gt;--allow-insecure-unlock&lt;/code&gt;就是为了方便这一步的。&lt;/p&gt;
&lt;p&gt;解锁命令为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-JS&#34; data-lang=&#34;JS&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;web3&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;personal&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;unlockAccount&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;web3&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;personal&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;listAccounts&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;],&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;password&amp;gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;15000&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后的数字代表解锁的时间，单位为秒。``代表你要解锁的账户的密码。&lt;/p&gt;
&lt;p&gt;虽然有另外一种解锁的方式，但是我没有成功。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-JS&#34; data-lang=&#34;JS&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;personal&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;unlockAccount&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;eth&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;accounts&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;],&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;password&amp;gt;&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;15000&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后就可以交易啦。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-JS&#34; data-lang=&#34;JS&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;eth&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;sendTransaction&lt;/span&gt;({&lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;eth&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;accounts&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#a6e22e&#34;&gt;to&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;eth&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;accounts&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;web3&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;toWei&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ether&amp;#34;&lt;/span&gt;)})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>