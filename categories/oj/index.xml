<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OJ on 洛舒luosuu的小站</title>
    <link>https://luosuu.github.io/categories/oj/</link>
    <description>Recent content in OJ on 洛舒luosuu的小站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright © 2020</copyright>
    <lastBuildDate>Sat, 08 Aug 2020 14:34:53 +0800</lastBuildDate>
    
	<atom:link href="https://luosuu.github.io/categories/oj/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>STsheet</title>
      <link>https://luosuu.github.io/post/stsheet/</link>
      <pubDate>Sat, 08 Aug 2020 14:34:53 +0800</pubDate>
      
      <guid>https://luosuu.github.io/post/stsheet/</guid>
      <description>&lt;p&gt;《浅谈ST表》完整请参考：https://www.luogu.com.cn/blog/zhouziheng666/qian-tan-st-biao&lt;/p&gt;
&lt;p&gt;核心要素&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查询操作可以重叠，如max操作&lt;code&gt;max(a,b,c)=max(max(a,b),max(b,c))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;采用倍增的方法构建，如果用$f(i,j)$代表从第i个数开始，共$2^j$个数的最大值，那么就有：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$
f(i,j)=max(f(i,j-1),f(i+2^{j-1},j-1))
$$&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;自然，$f(i,0)=a[i]$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于查询的时候，查询的长度可能是小于等于N的任何一个整数，设该查询的长度是&lt;code&gt;len&lt;/code&gt;，查询的数组的第一个数是整个数组的第&lt;code&gt;r&lt;/code&gt;个数。我们可以用$max[r,r+len]$来代表被查询的数组的最大值，以上面的函数的定义，可以用
$$
f(r,log_{2}(len))
$$
来表示。在输入数组总长度N后，我们需要对1到N的所有数求对数，提前存储好所有可能要用的&lt;code&gt;log(len)&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于某个从第&lt;code&gt;r&lt;/code&gt;个数开始的被查询的长度为&lt;code&gt;len&lt;/code&gt;数组，$f(r,log_{2}(len))$的实际来源为&lt;/p&gt;
&lt;p&gt;$$f(r,1)=max(f(r,1-1),f(r+2^{1-1},1-1))$$
$$f(r,2)=max(f(r,2-1),f(r+2^{2-1},2-1)) $$
$$f(r,3)=max(f(r,3-1),f(r+2^{3-1},3-1)) $$
$$&amp;hellip;$$
$$f(,log_{2}len)=max(f(r,log_{2}len-1),f(r+2^{log_{2}len-1},log_{2}len-1))$$&lt;/p&gt;
&lt;p&gt;在获取数组长度和数组内容后，实际上是用所有的$f(i,0)$获得了所有的$f(i,1)$，然后再用$f(i,1)$得到所有的$f(i,2)$（这个过程要保证$i+2^j$不超过N，否则会越界），一直到获得$f(0,log_{2}N)$。这样查询时，对于任意一个$f(r,log_{2}len)$都能立刻查询到，查询的复杂度为$O(1)$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果查询的数组长&lt;code&gt;len&lt;/code&gt;，$[log_{2}len]$代表&lt;code&gt;len&lt;/code&gt;对2取对数的向下取整，那么一次这种函数的构建最多能包含$2^{[log_{2}len]}$个数，如果&lt;code&gt;len&lt;/code&gt;不是2的倍数，那么就会有数不会被包括进去，所以实际上为了求该数组的最大值，是从左端和右边分别构建一个函数（$2^{[log_{2}len]}$肯定大于$len/2$），取这两个函数的最大值:
$$
max[r,r+len]=max(f(r,log(len)), f(r-log(len)+1,log(len)))
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于任何可以重叠的查询操作，都可以使用ST表这种方法，无非是从$f(i,0)$开始向上构建时采用的方法不同。但构建逻辑和数据结构是一样的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>2020shanghai B - 缓冲区结算、括号嵌套的递归</title>
      <link>https://luosuu.github.io/post/2020shanghai-b/</link>
      <pubDate>Thu, 06 Aug 2020 11:13:49 +0800</pubDate>
      
      <guid>https://luosuu.github.io/post/2020shanghai-b/</guid>
      <description>&lt;p&gt;题面:https://ac.nowcoder.com/acm/contest/6871/B&lt;/p&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;典型的字符串处理，而且出题人强调了没有括号嵌套（真亚撒西嘤嘤嘤）。&lt;/p&gt;
&lt;p&gt;因为分子式不同部分的计算方式是不一样的，可以用缓冲的思想来解决这个问题。&lt;/p&gt;
&lt;p&gt;在不考虑括号嵌套的情况下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; ll;
string a;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
    cin&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;a;
    ll ans&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,cnt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,res&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,sum&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; len&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a.length();
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;a.length();)
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(a[i]&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt;a[i]&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;H&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt;a[i]&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;O&amp;#39;&lt;/span&gt;){
             &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(a[i]&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;C&amp;#39;&lt;/span&gt;)cnt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;;
              &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(a[i]&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;H&amp;#39;&lt;/span&gt;)cnt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(a[i]&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;O&amp;#39;&lt;/span&gt;)cnt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;17&lt;/span&gt;;
            i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
            res&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;len&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;a[i]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;a[i]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;9&amp;#39;&lt;/span&gt;){
                res&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;res&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;a[i]&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;
                i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;res)ans&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;cnt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; ans&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;cnt&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;res;
        }

        &lt;span style=&#34;color:#75715e&#34;&gt;//遇到左括号，就先把未加进最终结果的非括号内元素们算入结果，清空缓冲区，准备计算括号内的分子式
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(a[i]&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;(&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;len){
          sum&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;ans;
            ans&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;//遇到右括号，结算括号内部的
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(a[i]&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;)&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;len){
            i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
            res&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
             &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;len&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;a[i]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;a[i]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;9&amp;#39;&lt;/span&gt;){
                res&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;res&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;a[i]&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;
                i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;res)sum&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;ans;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; sum&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;ans&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;res;
            ans&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        }
    }
    sum&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;ans;
    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%lld&amp;#34;&lt;/span&gt;,sum);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;用递归的方式处理括号嵌套&#34;&gt;用递归的方式处理括号嵌套&lt;/h3&gt;
&lt;p&gt;如果要考虑括号内部的嵌套，就需要用到递归的方法了。&lt;/p&gt;
&lt;p&gt;先说缓冲区的部分，遇到常规字符&lt;code&gt;C&lt;/code&gt;,&lt;code&gt;H&lt;/code&gt;,&lt;code&gt;O&lt;/code&gt;，将缓冲区算入结果，将常规字符的值读入缓冲区，以处理后面可能会出现的数字，括号等情况。&lt;/p&gt;
&lt;p&gt;遇到左括号，也是先将缓冲区算入结果，然后进入下一层函数，计算括号内部的分子式，遇到右括号时内部分子式返回来。如果内部还有括号，同理，会进入再下一层函数。最后将括号内的值读入缓冲区。&lt;/p&gt;
&lt;p&gt;遇到数字，就会继续往下读，直到把整个数字段都读出来（这个过程会转换为具体的数字&lt;code&gt;times&lt;/code&gt;）。然后将缓冲区内的值乘以times算入结果，清空缓冲区（这里清空缓冲区是必要的，虽然读入下一个数据的时候会覆盖它，但是如果已经是最后一个数据，就会跳出循环，执行最后的缓冲区内数据算入结果，如果不清空会多算一次）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define ll long long
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; in[&lt;span style=&#34;color:#ae81ff&#34;&gt;1000050&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; len;
ll &lt;span style=&#34;color:#a6e22e&#34;&gt;cal&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;now){
    ll tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,sum&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,times&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(now;now&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;len;){
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(in[now]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;in[now]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;9&amp;#39;&lt;/span&gt;){
            times&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(in[now]&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;);
            now&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(in[now]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;in[now]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;9&amp;#39;&lt;/span&gt;){
                times&lt;span style=&#34;color:#f92672&#34;&gt;*=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                times&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;(in[now]&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;);
                now&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
            }
            sum&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;tmp&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;times;
            tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;//遇到左括号时，先将缓冲区内部加入结果，然后进入下一层函数，计算内部分子式，遇到右括号再返回来
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(in[now]&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;(&amp;#39;&lt;/span&gt;){
            sum&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;tmp;
            now&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
            tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;cal(now);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(in[now]&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;)&amp;#39;&lt;/span&gt;){
            sum&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;tmp;
            now&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; sum;
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;//遇到常规字符也是把上一个缓冲区的内容加入结果，把当前的加入缓冲区，以处理后面可能会出现的数字
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(in[now]&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;C&amp;#39;&lt;/span&gt;){
            sum&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;tmp;
            tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;;
            now&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
        }&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(in[now]&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;H&amp;#39;&lt;/span&gt;){
            sum&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;tmp;
            tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            now&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
        }&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(in[now]&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;O&amp;#39;&lt;/span&gt;){
            sum&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;tmp;
            tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;17&lt;/span&gt;;
            now&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
        }
    }
    sum&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;tmp;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; sum;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solve&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; T){
    scanf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,in);
    len&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;strlen(in);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; now&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%lld&amp;#34;&lt;/span&gt;,cal(now));
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;signed&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; t&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#75715e&#34;&gt;//scanf(&amp;#34;%d&amp;#34;,&amp;amp;t);
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;t;i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;){
        solve(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>AtABC174 E-二分查找</title>
      <link>https://luosuu.github.io/post/atabc174-e/</link>
      <pubDate>Thu, 06 Aug 2020 10:04:10 +0800</pubDate>
      
      <guid>https://luosuu.github.io/post/atabc174-e/</guid>
      <description>&lt;p&gt;题面：https://atcoder.jp/contests/abc174/tasks/abc174_e&lt;/p&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;输入N个有长度&lt;code&gt;A[n]&lt;/code&gt;的原木，现在要一共对这些木头切至多K刀，求切K刀后所有木材最长的木材的最短值。即让切K刀后的所有木材的最长值尽量短。&lt;/p&gt;
&lt;p&gt;检验一个木材最长值&lt;code&gt;len&lt;/code&gt;是否符合切K刀的条件是简单的，只需要每个原木的长度除以&lt;code&gt;len&lt;/code&gt;向上取整再减一，然后取和，就能检验是否符合切K刀的条件。&lt;/p&gt;
&lt;p&gt;这类找出 “最长值的最短”“最小值的最大”一类，也就是&lt;code&gt;max(min(len))&lt;/code&gt;或&lt;code&gt;min(max(len))&lt;/code&gt;一般是使用二分查找方法的提示。&lt;/p&gt;
&lt;p&gt;在寻找最长木材的最小值的过程中，我们可以先用1做开头，原木中最长值&lt;code&gt;max_len&lt;/code&gt;做结尾，然后以这俩为首位进行二分查找。有三种情况&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当中值&lt;code&gt;mid&lt;/code&gt;的切割次数小于K次，说明&lt;code&gt;mid&lt;/code&gt;取的太长了，将&lt;code&gt;mid&lt;/code&gt;作为新的结尾；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果&lt;code&gt;mid&lt;/code&gt;的切割次数大于K次，说明取的太短了，应该把&lt;code&gt;mid&lt;/code&gt;作为新的开头；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当&lt;code&gt;mid&lt;/code&gt;的切割次数恰好等于K次，说明&lt;code&gt;mid&amp;gt;=最长木材的最小值&lt;/code&gt;，应该继续往下探，将&lt;code&gt;mid&lt;/code&gt;作为新的结尾。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cut_times&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;logs, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; cut_len, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; log_num);

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; N,K;
    cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; N &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; K;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; logs[N];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; max_long &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;N;i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;){
        cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; logs[i];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(logs[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; max_long) {
            max_long &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; logs[i];
        }
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(K&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;){
        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; max_long;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; start &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; end &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max_long;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; mid;

    &lt;span style=&#34;color:#75715e&#34;&gt;//binary search
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(start&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;end){
        mid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (start &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; end)&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(cut_times(logs, mid, N)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;K){&lt;span style=&#34;color:#75715e&#34;&gt;//cut times equals to k, still need to try a smaller one
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            end &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid;
        }&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(cut_times(logs, mid, N)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;K){
            start &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }

    }

    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; start;

}

&lt;span style=&#34;color:#75715e&#34;&gt;// Given max cut length, get needed cut times
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cut_times&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;logs, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; cut_len, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; log_num){
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;  need_times &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;log_num;i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;){
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;logs&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;cut_len&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;){
            need_times &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;logs&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;cut_len&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;{
            need_times &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;logs&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;cut_len;
        }
        logs&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; need_times;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Cf#661 A-输入输出</title>
      <link>https://luosuu.github.io/post/cf661-a/</link>
      <pubDate>Thu, 06 Aug 2020 08:41:45 +0800</pubDate>
      
      <guid>https://luosuu.github.io/post/cf661-a/</guid>
      <description>&lt;p&gt;题面：https://codeforces.com/contest/1399/problem/A&lt;/p&gt;
&lt;p&gt;存储每一例数据，排序，判断相邻的两个之间是否超过1即可。这里要注意的是输入输出的方式。&lt;/p&gt;
&lt;p&gt;以下注释掉的地方也都是可以采用的方式。&lt;/p&gt;
&lt;p&gt;其中一种方式是避免动态数组，使用用提前规定好的最大数组。（虽然这个题用动态数组也过了）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;stdio.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;algorithm&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;iostream&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#75715e&#34;&gt;//int a[1050];
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solve&lt;/span&gt;(){
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n;
  &lt;span style=&#34;color:#75715e&#34;&gt;//  scanf(&amp;#34;%d&amp;#34;,&amp;amp;n);
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; n;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a[n];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
  &lt;span style=&#34;color:#75715e&#34;&gt;//      scanf(&amp;#34;%d&amp;#34;,&amp;amp;a[i]);
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; a[i];
    }
    sort(a,a&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;n);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(a[i]&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;a[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;){
        &lt;span style=&#34;color:#75715e&#34;&gt;//    puts(&amp;#34;NO&amp;#34;);
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;NO&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
    }
   &lt;span style=&#34;color:#75715e&#34;&gt;// puts(&amp;#34;YES&amp;#34;);
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YES&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; t;
   &lt;span style=&#34;color:#75715e&#34;&gt;// scanf(&amp;#34;%d&amp;#34;,&amp;amp;t);
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; t;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; t; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
        solve();
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;another&#34;&gt;another&lt;/h3&gt;
&lt;p&gt;还有一道题也是和输入输出相关的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大学的同学来自全国各地，对于远离家乡步入陌生大学校园的大一新生来说，碰到老乡是多么激动的一件事，于是大家都热衷于问身边的同学是否与自己同乡，来自新疆的小赛尤其热衷。但是大家都不告诉小赛他们来自哪里，只是说与谁是不是同乡，从所给的信息中，你能告诉小赛有多少人确定是她的同乡吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包含多组测试用例。&lt;/p&gt;
&lt;p&gt;对于每组测试用例：&lt;/p&gt;
&lt;p&gt;第一行包括2个整数，N（1 &amp;lt;= N &amp;lt;= 1000），M(0 &amp;lt;= M &amp;lt;= N*(N-1)/2)，代表现有N个人（用1~N编号）和M组关系；&lt;/p&gt;
&lt;p&gt;在接下来的M行里，每行包括3个整数，a，b, c，如果c为1，则代表a跟b是同乡；如果c为0，则代表a跟b不是同乡；&lt;/p&gt;
&lt;p&gt;已知1表示小赛本人。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3 1&lt;/p&gt;
&lt;p&gt;2 3 1&lt;/p&gt;
&lt;p&gt;5 4&lt;/p&gt;
&lt;p&gt;1 2 1&lt;/p&gt;
&lt;p&gt;3 4 0&lt;/p&gt;
&lt;p&gt;2 5 1&lt;/p&gt;
&lt;p&gt;3 2 1&lt;/p&gt;
&lt;p&gt;本题的输入部分可以这样写&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;()
{
   &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; N, M;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 每组第一行是2个整数，N和M，至于为啥用while，因为是多组。
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(scanf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d %d&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;N, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;M) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; EOF) {
      printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d %d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, N, M);
      &lt;span style=&#34;color:#75715e&#34;&gt;// 循环读取“接下来的M行”
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;M; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, b, c;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 每行是3个整数，a，b，c。
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        scanf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d %d %d&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;a, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;b, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;c);
        printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d %d %d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, a, b, c);
      }
      &lt;span style=&#34;color:#75715e&#34;&gt;// M行读取完了，就又要开始下一组了，去while那里。
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;and-another-one&#34;&gt;and another one!&lt;/h3&gt;
&lt;p&gt;还有一道题是&lt;a href=&#34;https://ac.nowcoder.com/acm/contest/6871/C&#34;&gt;2020上海高校程序设计竞赛的C题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;计算每一例聊天记录里，含&lt;code&gt;2&lt;/code&gt;的句子占的比例。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; T;
    cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; T;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; rate[T];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; num[T];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T;i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;){
        num[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n;
        cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; n;
        getchar();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;j&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n;j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;){
            string in;
            getline(cin,in);

            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; in.size();
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;k&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;len;k&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;){
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(in[k]&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2&amp;#39;&lt;/span&gt;){
                    num[i]&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
                }
            }
        }
        rate[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; num[i]&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;(n&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;);
        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; rate[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;one-more-thing&#34;&gt;one more thing&lt;/h3&gt;
&lt;p&gt;转载一下&lt;a href=&#34;https://blog.csdn.net/m0_38059875/article/details/105205096&#34;&gt;CSDN上的OJ之C++输入输出总结&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;不知道输入几组&#34;&gt;不知道输入几组&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;计算a+b的和&lt;/p&gt;
&lt;p&gt;每行包含两个整数a和b&lt;/p&gt;
&lt;p&gt;对于每行输入对应输出一行a和b的和&lt;/p&gt;
&lt;p&gt;输入&lt;/p&gt;
&lt;p&gt;1 5&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a,b;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; b)&lt;span style=&#34;color:#75715e&#34;&gt;//注意while处理多个case
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;知道输入几组&#34;&gt;知道输入几组&lt;/h4&gt;
&lt;p&gt;先输入一个组数n，然后再循环读取n组数据。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n; &lt;span style=&#34;color:#75715e&#34;&gt;// 数据的组数
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; n; &lt;span style=&#34;color:#75715e&#34;&gt;// 读取组数
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i){
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, b;
        cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; b;
        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;字符串的输入处理&#34;&gt;字符串的输入处理&lt;/h4&gt;
&lt;p&gt;因为OJ最终只比较文件，就不用保存所有输入，可以读一组数据计算一组数据。&lt;/p&gt;
&lt;p&gt;当读取字符串的时候需要注意，&lt;code&gt;cin&lt;/code&gt;不能读取空白字符，比如空格，如果遇到空格则会直接终止字符串。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
	string s;
	cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; s; &lt;span style=&#34;color:#75715e&#34;&gt;// 读到空白就结束当前的字符串
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行的结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;abc &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;
abc请按任意键继续. . .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果要读取整行字符串，可以使用&lt;code&gt;getline()&lt;/code&gt;和&lt;code&gt;cin.getline()&lt;/code&gt;这两个函数，两个函数都是遇到定界符，则结束这行的字符串，定界符默认设置为&lt;strong&gt;回车&lt;/strong&gt;。两个函数略有不同的是，&lt;code&gt;getline()&lt;/code&gt;操作的对象是string，&lt;code&gt;cin.getline()&lt;/code&gt;操作的对象的char数组。详细的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getline()&lt;/code&gt;，要使用这个函数需要包含头文件&amp;lt;string&amp;gt;，&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;istream&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; getline(istream&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; is, string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; str, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; delim);
istream&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; getline(istream&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; is, string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; str);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;is：它是istream类的对象，告诉函数从何处读取输入流。&lt;/li&gt;
&lt;li&gt;str：这是一个string字符串对象，从流中读取输入后，将输入存储在此对象中。&lt;/li&gt;
&lt;li&gt;delim：这是定界字符，它告诉函数在达到该字符后停止读取进一步的输入。&lt;/li&gt;
&lt;li&gt;返回值：此函数返回值是与输入参数is相同的输入流。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
	string s;
	getline(cin, s);
	cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s;	
	system(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}		
&lt;span style=&#34;color:#ae81ff&#34;&gt;12345678910&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;abc &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;
abc 123请按任意键继续. . .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;cin.getline()&lt;/code&gt;函数读取至新行结尾或直到达到最大限制的整行文本。函数定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// (buffer, stream_size, delimiter)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;istream&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; getline(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; size, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;)

&lt;span style=&#34;color:#75715e&#34;&gt;// The delimiter character is considered as &amp;#39;\n&amp;#39;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;istream&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; getline(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; size)
&lt;span style=&#34;color:#ae81ff&#34;&gt;12345&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;提取字符直到定界符。&lt;/li&gt;
&lt;li&gt;将字符存储在缓冲区中。&lt;/li&gt;
&lt;li&gt;提取的最大字符数为&lt;code&gt;size-1&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt; &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std; 
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() 
{ 
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; str[&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;]; 
    cin.getline(str, &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;); 
    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; str; 
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; 
}
&lt;span style=&#34;color:#ae81ff&#34;&gt;123456789&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;no bug forever
no bug forever请按任意键继续. . .
&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;输入为9个数字，每个数字用&lt;code&gt;逗号,&lt;/code&gt;分隔，将数字保存到一个一维数组中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1,2,3,4,5,6,7,8,9&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt;() {
	string str;
	cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; str; &lt;span style=&#34;color:#75715e&#34;&gt;// 获取整行数据
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vec; &lt;span style=&#34;color:#75715e&#34;&gt;// 将数字保存在数组中
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; ch : str) {
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isdigit(ch)) vec.push_back(ch &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 如果是数字才保存，并且需要减去字符0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; i : vec) {
		cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;;
	}
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
	test();
	system(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;span style=&#34;color:#ae81ff&#34;&gt;123456789101112131415161718192021&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;1,2,3,4,5,6,7,8,9
&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt; 请按任意键继续. . .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>AtABC174C-模运算</title>
      <link>https://luosuu.github.io/post/atabc174_c/</link>
      <pubDate>Tue, 04 Aug 2020 17:04:51 +0800</pubDate>
      
      <guid>https://luosuu.github.io/post/atabc174_c/</guid>
      <description>&lt;p&gt;题面：https://atcoder.jp/contests/abc174/tasks/abc174_c&lt;/p&gt;
&lt;p&gt;本题可以简单化简 $$ K \cdot a=7 \cdot \frac{1-10^n}{1-10} $$&lt;/p&gt;
&lt;p&gt;等同于 $$ K \cdot a \cdot 9=7 \cdot (10^n-1) $$&lt;/p&gt;
&lt;p&gt;a是K的倍数，n为被除数的位数，n即为所求。只要右侧式能够整除9K（a是个整数），那么就满足要求。&lt;/p&gt;
&lt;p&gt;于是调试n，用右侧式对左侧进行取模操作即可。&lt;/p&gt;
&lt;p&gt;但计算过程中有$10^n$的限制，可能会超过&lt;code&gt;long long &lt;/code&gt;数据的最大值。&lt;/p&gt;
&lt;p&gt;这里要引出取模运算的运算规则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(a+b)%p=(a%p+b%p)%p
(a-b)%p=(a%p-b%p)%p
(a*b%p)=(a%p * b%p)%p
(a^b)%p=((a%p)^b)%p
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;观察右侧式，先抛去7这个乘数，它的变化应该是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;9
99
999
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以表示为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;d(0)=9
d(1)=d(0)*10+9
d(2)=d(1)*10+9
...
d(n)=d(n-1)*10+9
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在要求&lt;code&gt;d(n)&lt;/code&gt;能不能整除&lt;code&gt;9K&lt;/code&gt;，可以递推式的表达，这样循环中每一次验证都只需要一次计算。&lt;/p&gt;
&lt;p&gt;最后考虑停机条件，时间限制为2s，以CPU 1GHz的速度来考虑，保守的可以设置停机条件为2e7。如果2e7位数还没有找到，大概率是没有了。&lt;/p&gt;
&lt;p&gt;完整的代码可以写为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; K;
    cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; K;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; K;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(K &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; K &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;){
        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;20000000&lt;/span&gt;;i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;){
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;((&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;d)&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;){
            cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; i;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        }
        d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (d&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;s;
    }
    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;one-more-thing&#34;&gt;one more thing&lt;/h3&gt;
&lt;p&gt;关于模运算有很多有趣的知识，其中一些在OJ中经常常用，快速幂就是其中一个。&lt;/p&gt;
&lt;p&gt;快速幂的全称是“快速计算一个幂式的模（余）”&lt;/p&gt;
&lt;p&gt;假如我们要计算&lt;code&gt;a^b mod c&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果我们直接算&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;b;i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
{
  ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a;
}
ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; c;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么当b比较大的时候，&lt;code&gt;long long &lt;/code&gt;也是撑不住的，数据会溢出。&lt;/p&gt;
&lt;p&gt;可以根据模运算的性质&lt;code&gt;(a^b)%p=((a%p)^b)%p&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在算指数之前先取模，这样可以小一些&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; c;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;b;i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
{
  ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a;
}
ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; c;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果一个因子取余不影响最终结果，那么中间的因子取余应该也是不影响结果的（反正最后都被消掉，可以在计算指数的过程中消掉）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; c;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;b;i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
{
  ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (ans &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a)&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;c;
}
ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; c;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在已经比最开始好很多了，但现在的复杂度式还是&lt;code&gt;O(b)&lt;/code&gt;，当b比较大的时候还是有可能超时。&lt;/p&gt;
&lt;p&gt;也就是问题出现在求指数的过程中，这里要考虑到如何快速计算幂式，我们可以这样考虑
$$
2^{1000}=4^{500}
$$
底数做一次平方，运算次数少了一半，如果是奇数
$$
2^{1001}=4^{500}*2
$$
现在先不考虑幂式求模余的问题，如果单纯要求快速计算&lt;code&gt;a^b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方法应该是这样的&lt;/p&gt;
&lt;p&gt;当指数b是偶数时，平方底数，指数b自除2；&lt;/p&gt;
&lt;p&gt;当指数b是奇数时，先用一个数才收集落单的底数，然后平方底数，b自减1再除2。&lt;/p&gt;
&lt;p&gt;最后除到b为1的时候，用于收集落单的底数的数就会乘以最后的底，从而变成最终结果。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;QuickPower&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a,&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b){
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(b&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;){
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(b &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;){
            result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; result&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;a;
            b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
        b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; b&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如何应用在求幂式的模余中呢？应该是很简单的。&lt;/p&gt;
&lt;p&gt;当指数b是偶数时，平方底数，指数b自除2；&lt;/p&gt;
&lt;p&gt;当指数b是奇数时，先让ans乘以底数a（这里可以对c取模优化），用于收集落单的底数，然后平方底数，b自减1再除2。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PowerMod&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; c)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; c;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(b&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(b &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;){
            ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (ans &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a) &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; c;
        }
      &lt;span style=&#34;color:#75715e&#34;&gt;//由于是整形，不减1直接除二也是可以的
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; b&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
     &lt;span style=&#34;color:#75715e&#34;&gt;// 下面这种写法也是可以的，右移操作也是可以实现除二，并且自动舍去了余数（就是对整数这样操作不tidy）
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;// b = b &amp;gt;&amp;gt; 1 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (a &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a) &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; c;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ans;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>